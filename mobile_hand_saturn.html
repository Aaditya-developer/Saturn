<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mobile Hand-Controlled Saturn</title>
<style>
body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
canvas { display: block; }

#video-container {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 160px;
    height: 120px;
    border: 2px solid #555;
    border-radius: 8px;
    overflow: hidden;
    background: #222;
}
video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

#status {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 5px;
}
</style>
</head>
<body>

<div id="status">Loading Hand Tracking...</div>
<div id="video-container">
    <video id="input_video" autoplay playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const videoElement = document.getElementById('input_video');
const statusElement = document.getElementById('status');

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const saturnGroup = new THREE.Group();
scene.add(saturnGroup);

function createVoxelSphere(radius, density, color, size){
    const group = new THREE.Group();
    const geometry = new THREE.BoxGeometry(size,size,size);
    const material = new THREE.MeshStandardMaterial({ color });
    for(let i=0;i<density;i++){
        const phi=Math.acos(-1+(2*i)/density);
        const theta=Math.sqrt(density*Math.PI)*phi;
        const x = radius*Math.cos(theta)*Math.sin(phi);
        const y = radius*Math.sin(theta)*Math.sin(phi);
        const z = radius*Math.cos(phi);
        const cube = new THREE.Mesh(geometry,material);
        cube.position.set(x,y,z);
        group.add(cube);
    }
    return group;
}

const body = createVoxelSphere(3,800,0xdfd195,0.15);
saturnGroup.add(body);

const ringGroup = new THREE.Group();
for(let i=0;i<1500;i++){
    const r = 4.5 + Math.random()*(7-4.5);
    const theta = Math.random()*Math.PI*2;
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(0.1,0.02,0.1),
        new THREE.MeshStandardMaterial({color:0xc5b358, transparent:true, opacity:0.7})
    );
    cube.position.set(Math.cos(theta)*r, (Math.random()-0.5)*0.1, Math.sin(theta)*r);
    ringGroup.add(cube);
}
saturnGroup.add(ringGroup);

const light = new THREE.PointLight(0xffffff,1.5);
light.position.set(10,10,10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

camera.position.z = 12;

// --- HAND TRACKING ---
function onResults(results){
    if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
        statusElement.innerText = "Hand Detected!";
        const hand = results.multiHandLandmarks[0];
        const indexTip = hand[8];
        const targetRotationX = (indexTip.y - 0.5) * 4;
        const targetRotationY = (indexTip.x - 0.5) * 4;
        saturnGroup.rotation.x += (targetRotationX - saturnGroup.rotation.x) * 0.1;
        saturnGroup.rotation.y += (targetRotationY - saturnGroup.rotation.y) * 0.1;
    } else {
        statusElement.innerText = "Show your hand to the camera";
    }
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);

const cameraFeed = new Camera(videoElement, {
    onFrame: async ()=>{ await hands.send({image: videoElement}); },
    width: 320,
    height: 240
});
cameraFeed.start();

// --- ANIMATION LOOP ---
function animate(){
    requestAnimationFrame(animate);
    ringGroup.rotation.y += 0.001;
    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
